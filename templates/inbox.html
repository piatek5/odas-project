<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Skrzynka Odbiorcza - ODAS</title>
    <style>
        .message-card { border: 1px solid #ccc; padding: 10px; margin: 10px 0; border-radius: 5px; }
        .sender { font-weight: bold; color: #2c3e50; }
        .time { font-size: 0.8em; color: #7f8c8d; }
    </style>
</head>
<body>
    <h1>Twoje zaszyfrowane wiadomości</h1>
    <div id="status"></div>
    <div id="messagesList"></div>

    <hr>
    <a href="/send">Wyślij nową wiadomość</a> | <a href="/login">Wyloguj</a>

    <script src="{{ url_for('static', filename='js/crypto.js') }}"></script>
    <script src="{{ url_for('static', filename='js/auth.js') }}"></script>
    <script>
        async function loadInbox() {
            const status = document.getElementById('status');
            const list = document.getElementById('messagesList');
            const userId = window.sessionStorage.getItem('currentUserId');

            if (!userId) {
                status.innerHTML = "<b style='color:red'>Zaloguj się!</b>";
                return;
            }

            try {
                const res = await fetch(`/api/messages/inbox/${userId}`);
                const messages = await res.json();

                if (messages.length === 0) {
                    list.innerHTML = "<p>Brak wiadomości.</p>";
                    return;
                }

                status.innerText = "Dekodowanie wiadomości...";
                
                for (const msg of messages) {
                    try {
                        const decryptedData = await decryptIncomingMessage(msg);
                        
                        const card = document.createElement('div');
                        card.className = 'message-card';
                        card.innerHTML = `
                            <div class="sender">Od: ${msg.sender_username}</div>
                            <p>${decryptedData.text}</p>
                            <div class="files">
                                ${decryptedData.attachments.map(f => `<a href="${f.data}" download="${f.name}">Pobierz ${f.name}</a>`).join('<br>')}
                            </div>
                        `;
                        list.appendChild(card);
                    } catch (e) {
                        console.error("Błąd deszyfracji wiadomości:", e);
                    }
                }
                status.innerText = "";
            } catch (err) {
                status.innerHTML = "<b style='color:red'>Błąd ładowania skrzynki.</b>";
            }
        }

        async function decryptIncomingMessage(msg) {
            // Przygotowanie klucza publicznego nadawcy do weryfikacji
            const senderPubKeyEdRaw = base64ToArrayBuffer(msg.sender_pub_key_ed25519);
            const publicKeyEd = await window.crypto.subtle.importKey(
                "raw", senderPubKeyEdRaw, { name: "Ed25519" }, true, ["verify"]
            );

            // WERYFIKACJA PODPISU
            const isSignatureValid = await window.crypto.subtle.verify(
                { name: "Ed25519" },
                publicKeyEd,
                base64ToArrayBuffer(msg.signature),
                base64ToArrayBuffer(msg.encrypted_payload)
            );

            if (!isSignatureValid) {
                throw new Error("UWAGA: Podpis cyfrowy jest nieprawidłowy! Wiadomość mogła zostać sfałszowana.");
            }

            // Odzyskanie klucza prywatnego (analogicznie do sendMessage)
            let privKey = window.myPrivateKeyX;
            if (!privKey) {
                // To wywoła prompt o hasło tylko raz przy ładowaniu strony
                const password = prompt("Wpisz hasło, aby odczytać wiadomości:");
                const salt = base64ToArrayBuffer(window.sessionStorage.getItem('userSalt'));
                const masterKey = await cryptoLib.deriveMasterKey(password, salt);
                privKey = await window.crypto.subtle.unwrapKey(
                    "pkcs8",
                    base64ToArrayBuffer(window.sessionStorage.getItem('wrappedKeyX')),
                    masterKey,
                    { name: "AES-GCM", iv: new Uint8Array(12) },
                    { name: "X25519" },
                    true, ["deriveKey", "deriveBits"]
                );
                window.myPrivateKeyX = privKey;
            }

            // ECDH - Uzgodnienie klucza z nadawcą
            const senderPubKeyRaw = base64ToArrayBuffer(msg.sender_pub_key);
            const sharedKey = await messageCrypto.deriveSharedSecret(privKey, senderPubKeyRaw);

            // Deszyfracja AES-GCM
            const decryptedBuffer = await window.crypto.subtle.decrypt(
                { name: "AES-GCM", iv: base64ToArrayBuffer(msg.iv) },
                sharedKey,
                base64ToArrayBuffer(msg.encrypted_payload)
            );

            const decryptedJson = new TextDecoder().decode(decryptedBuffer);
            const messageData = JSON.parse(decryptedJson);

            // Zwracamy obiekt zamiast stringa
            return messageData;
        }

        window.onload = loadInbox;
    </script>
</body>
</html>